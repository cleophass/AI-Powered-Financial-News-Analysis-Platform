{"version":3,"sources":["../../../../../../../../libs/protos/src/generated/base/google/protobuf/struct.ts"],"sourcesContent":["// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.5.0\n//   protoc               v5.29.1\n// source: google/protobuf/struct.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\n\n/**\n * `NullValue` is a singleton enumeration to represent the null value for the\n * `Value` type union.\n *\n * The JSON representation for `NullValue` is JSON `null`.\n */\nexport enum NullValue {\n  /** NULL_VALUE - Null value. */\n  NULL_VALUE = 0,\n  UNRECOGNIZED = -1,\n}\n\nexport function nullValueFromJSON(object: any): NullValue {\n  switch (object) {\n    case 0:\n    case \"NULL_VALUE\":\n      return NullValue.NULL_VALUE;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return NullValue.UNRECOGNIZED;\n  }\n}\n\nexport function nullValueToJSON(object: NullValue): string {\n  switch (object) {\n    case NullValue.NULL_VALUE:\n      return \"NULL_VALUE\";\n    case NullValue.UNRECOGNIZED:\n    default:\n      return \"UNRECOGNIZED\";\n  }\n}\n\n/**\n * `Struct` represents a structured data value, consisting of fields\n * which map to dynamically typed values. In some languages, `Struct`\n * might be supported by a native representation. For example, in\n * scripting languages like JS a struct is represented as an\n * object. The details of that representation are described together\n * with the proto support for the language.\n *\n * The JSON representation for `Struct` is JSON object.\n */\nexport interface Struct {\n  /** Unordered map of dynamically typed values. */\n  fields: { [key: string]: any | undefined };\n}\n\nexport interface Struct_FieldsEntry {\n  key: string;\n  value: any | undefined;\n}\n\n/**\n * `Value` represents a dynamically typed value which can be either\n * null, a number, a string, a boolean, a recursive struct value, or a\n * list of values. A producer of value is expected to set one of these\n * variants. Absence of any variant indicates an error.\n *\n * The JSON representation for `Value` is JSON value.\n */\nexport interface Value {\n  /** Represents a null value. */\n  nullValue?:\n    | NullValue\n    | undefined;\n  /** Represents a double value. */\n  numberValue?:\n    | number\n    | undefined;\n  /** Represents a string value. */\n  stringValue?:\n    | string\n    | undefined;\n  /** Represents a boolean value. */\n  boolValue?:\n    | boolean\n    | undefined;\n  /** Represents a structured value. */\n  structValue?:\n    | { [key: string]: any }\n    | undefined;\n  /** Represents a repeated `Value`. */\n  listValue?: Array<any> | undefined;\n}\n\n/**\n * `ListValue` is a wrapper around a repeated field of values.\n *\n * The JSON representation for `ListValue` is JSON array.\n */\nexport interface ListValue {\n  /** Repeated field of dynamically typed values. */\n  values: any[];\n}\n\nfunction createBaseStruct(): Struct {\n  return { fields: {} };\n}\n\nexport const Struct: MessageFns<Struct> & StructWrapperFns = {\n  encode(message: Struct, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    Object.entries(message.fields).forEach(([key, value]) => {\n      if (value !== undefined) {\n        Struct_FieldsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();\n      }\n    });\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Struct {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseStruct();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          const entry1 = Struct_FieldsEntry.decode(reader, reader.uint32());\n          if (entry1.value !== undefined) {\n            message.fields[entry1.key] = entry1.value;\n          }\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Struct {\n    return {\n      fields: isObject(object.fields)\n        ? Object.entries(object.fields).reduce<{ [key: string]: any | undefined }>((acc, [key, value]) => {\n          acc[key] = value as any | undefined;\n          return acc;\n        }, {})\n        : {},\n    };\n  },\n\n  toJSON(message: Struct): unknown {\n    const obj: any = {};\n    if (message.fields) {\n      const entries = Object.entries(message.fields);\n      if (entries.length > 0) {\n        obj.fields = {};\n        entries.forEach(([k, v]) => {\n          obj.fields[k] = v;\n        });\n      }\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<Struct>, I>>(base?: I): Struct {\n    return Struct.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Struct>, I>>(object: I): Struct {\n    const message = createBaseStruct();\n    message.fields = Object.entries(object.fields ?? {}).reduce<{ [key: string]: any | undefined }>(\n      (acc, [key, value]) => {\n        if (value !== undefined) {\n          acc[key] = value;\n        }\n        return acc;\n      },\n      {},\n    );\n    return message;\n  },\n\n  wrap(object: { [key: string]: any } | undefined): Struct {\n    const struct = createBaseStruct();\n\n    if (object !== undefined) {\n      for (const key of Object.keys(object)) {\n        struct.fields[key] = object[key];\n      }\n    }\n    return struct;\n  },\n\n  unwrap(message: Struct): { [key: string]: any } {\n    const object: { [key: string]: any } = {};\n    if (message.fields) {\n      for (const key of Object.keys(message.fields)) {\n        object[key] = message.fields[key];\n      }\n    }\n    return object;\n  },\n};\n\nfunction createBaseStruct_FieldsEntry(): Struct_FieldsEntry {\n  return { key: \"\", value: undefined };\n}\n\nexport const Struct_FieldsEntry: MessageFns<Struct_FieldsEntry> = {\n  encode(message: Struct_FieldsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.key !== \"\") {\n      writer.uint32(10).string(message.key);\n    }\n    if (message.value !== undefined) {\n      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Struct_FieldsEntry {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseStruct_FieldsEntry();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.key = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Struct_FieldsEntry {\n    return {\n      key: isSet(object.key) ? globalThis.String(object.key) : \"\",\n      value: isSet(object?.value) ? object.value : undefined,\n    };\n  },\n\n  toJSON(message: Struct_FieldsEntry): unknown {\n    const obj: any = {};\n    if (message.key !== \"\") {\n      obj.key = message.key;\n    }\n    if (message.value !== undefined) {\n      obj.value = message.value;\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<Struct_FieldsEntry>, I>>(base?: I): Struct_FieldsEntry {\n    return Struct_FieldsEntry.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Struct_FieldsEntry>, I>>(object: I): Struct_FieldsEntry {\n    const message = createBaseStruct_FieldsEntry();\n    message.key = object.key ?? \"\";\n    message.value = object.value ?? undefined;\n    return message;\n  },\n};\n\nfunction createBaseValue(): Value {\n  return {\n    nullValue: undefined,\n    numberValue: undefined,\n    stringValue: undefined,\n    boolValue: undefined,\n    structValue: undefined,\n    listValue: undefined,\n  };\n}\n\nexport const Value: MessageFns<Value> & AnyValueWrapperFns = {\n  encode(message: Value, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.nullValue !== undefined) {\n      writer.uint32(8).int32(message.nullValue);\n    }\n    if (message.numberValue !== undefined) {\n      writer.uint32(17).double(message.numberValue);\n    }\n    if (message.stringValue !== undefined) {\n      writer.uint32(26).string(message.stringValue);\n    }\n    if (message.boolValue !== undefined) {\n      writer.uint32(32).bool(message.boolValue);\n    }\n    if (message.structValue !== undefined) {\n      Struct.encode(Struct.wrap(message.structValue), writer.uint32(42).fork()).join();\n    }\n    if (message.listValue !== undefined) {\n      ListValue.encode(ListValue.wrap(message.listValue), writer.uint32(50).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Value {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseValue();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 8) {\n            break;\n          }\n\n          message.nullValue = reader.int32() as any;\n          continue;\n        }\n        case 2: {\n          if (tag !== 17) {\n            break;\n          }\n\n          message.numberValue = reader.double();\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.stringValue = reader.string();\n          continue;\n        }\n        case 4: {\n          if (tag !== 32) {\n            break;\n          }\n\n          message.boolValue = reader.bool();\n          continue;\n        }\n        case 5: {\n          if (tag !== 42) {\n            break;\n          }\n\n          message.structValue = Struct.unwrap(Struct.decode(reader, reader.uint32()));\n          continue;\n        }\n        case 6: {\n          if (tag !== 50) {\n            break;\n          }\n\n          message.listValue = ListValue.unwrap(ListValue.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): Value {\n    return {\n      nullValue: isSet(object.nullValue) ? nullValueFromJSON(object.nullValue) : undefined,\n      numberValue: isSet(object.numberValue) ? globalThis.Number(object.numberValue) : undefined,\n      stringValue: isSet(object.stringValue) ? globalThis.String(object.stringValue) : undefined,\n      boolValue: isSet(object.boolValue) ? globalThis.Boolean(object.boolValue) : undefined,\n      structValue: isObject(object.structValue) ? object.structValue : undefined,\n      listValue: globalThis.Array.isArray(object.listValue) ? [...object.listValue] : undefined,\n    };\n  },\n\n  toJSON(message: Value): unknown {\n    const obj: any = {};\n    if (message.nullValue !== undefined) {\n      obj.nullValue = nullValueToJSON(message.nullValue);\n    }\n    if (message.numberValue !== undefined) {\n      obj.numberValue = message.numberValue;\n    }\n    if (message.stringValue !== undefined) {\n      obj.stringValue = message.stringValue;\n    }\n    if (message.boolValue !== undefined) {\n      obj.boolValue = message.boolValue;\n    }\n    if (message.structValue !== undefined) {\n      obj.structValue = message.structValue;\n    }\n    if (message.listValue !== undefined) {\n      obj.listValue = message.listValue;\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<Value>, I>>(base?: I): Value {\n    return Value.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Value>, I>>(object: I): Value {\n    const message = createBaseValue();\n    message.nullValue = object.nullValue ?? undefined;\n    message.numberValue = object.numberValue ?? undefined;\n    message.stringValue = object.stringValue ?? undefined;\n    message.boolValue = object.boolValue ?? undefined;\n    message.structValue = object.structValue ?? undefined;\n    message.listValue = object.listValue ?? undefined;\n    return message;\n  },\n\n  wrap(value: any): Value {\n    const result = createBaseValue();\n    if (value === null) {\n      result.nullValue = NullValue.NULL_VALUE;\n    } else if (typeof value === \"boolean\") {\n      result.boolValue = value;\n    } else if (typeof value === \"number\") {\n      result.numberValue = value;\n    } else if (typeof value === \"string\") {\n      result.stringValue = value;\n    } else if (globalThis.Array.isArray(value)) {\n      result.listValue = value;\n    } else if (typeof value === \"object\") {\n      result.structValue = value;\n    } else if (typeof value !== \"undefined\") {\n      throw new globalThis.Error(\"Unsupported any value type: \" + typeof value);\n    }\n    return result;\n  },\n\n  unwrap(message: any): string | number | boolean | Object | null | Array<any> | undefined {\n    if (message.stringValue !== undefined) {\n      return message.stringValue;\n    } else if (message?.numberValue !== undefined) {\n      return message.numberValue;\n    } else if (message?.boolValue !== undefined) {\n      return message.boolValue;\n    } else if (message?.structValue !== undefined) {\n      return message.structValue as any;\n    } else if (message?.listValue !== undefined) {\n      return message.listValue;\n    } else if (message?.nullValue !== undefined) {\n      return null;\n    }\n    return undefined;\n  },\n};\n\nfunction createBaseListValue(): ListValue {\n  return { values: [] };\n}\n\nexport const ListValue: MessageFns<ListValue> & ListValueWrapperFns = {\n  encode(message: ListValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    for (const v of message.values) {\n      Value.encode(Value.wrap(v!), writer.uint32(10).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ListValue {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseListValue();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.values.push(Value.unwrap(Value.decode(reader, reader.uint32())));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ListValue {\n    return { values: globalThis.Array.isArray(object?.values) ? [...object.values] : [] };\n  },\n\n  toJSON(message: ListValue): unknown {\n    const obj: any = {};\n    if (message.values?.length) {\n      obj.values = message.values;\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<ListValue>, I>>(base?: I): ListValue {\n    return ListValue.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ListValue>, I>>(object: I): ListValue {\n    const message = createBaseListValue();\n    message.values = object.values?.map((e) => e) || [];\n    return message;\n  },\n\n  wrap(array: Array<any> | undefined): ListValue {\n    const result = createBaseListValue();\n    result.values = array ?? [];\n    return result;\n  },\n\n  unwrap(message: ListValue): Array<any> {\n    if (message?.hasOwnProperty(\"values\") && globalThis.Array.isArray(message.values)) {\n      return message.values;\n    } else {\n      return message as any;\n    }\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\ntype DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\ntype Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\nfunction isObject(value: any): boolean {\n  return typeof value === \"object\" && value !== null;\n}\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n\ninterface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  fromJSON(object: any): T;\n  toJSON(message: T): unknown;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n\ninterface StructWrapperFns {\n  wrap(object: { [key: string]: any } | undefined): Struct;\n  unwrap(message: Struct): { [key: string]: any };\n}\n\ninterface AnyValueWrapperFns {\n  wrap(value: any): Value;\n  unwrap(message: any): string | number | boolean | Object | null | Array<any> | undefined;\n}\n\ninterface ListValueWrapperFns {\n  wrap(array: Array<any> | undefined): ListValue;\n  unwrap(message: ListValue): Array<any>;\n}\n"],"names":["ListValue","NullValue","Struct","Struct_FieldsEntry","Value","nullValueFromJSON","nullValueToJSON","object","createBaseStruct","fields","encode","message","writer","BinaryWriter","Object","entries","forEach","key","value","undefined","uint32","fork","join","decode","input","length","reader","BinaryReader","end","len","pos","tag","entry1","skip","fromJSON","isObject","reduce","acc","toJSON","obj","k","v","create","base","fromPartial","wrap","struct","keys","unwrap","createBaseStruct_FieldsEntry","string","isSet","globalThis","String","createBaseValue","nullValue","numberValue","stringValue","boolValue","structValue","listValue","int32","double","bool","Number","Boolean","Array","isArray","result","Error","createBaseListValue","values","push","map","e","array","hasOwnProperty"],"mappings":"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"}
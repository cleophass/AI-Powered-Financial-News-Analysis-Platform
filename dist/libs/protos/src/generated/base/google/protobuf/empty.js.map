{"version":3,"sources":["../../../../../../../../libs/protos/src/generated/base/google/protobuf/empty.ts"],"sourcesContent":["// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.5.0\n//   protoc               v5.29.1\n// source: google/protobuf/empty.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\n\n/**\n * A generic empty message that you can re-use to avoid defining duplicated\n * empty messages in your APIs. A typical example is to use it as the request\n * or the response type of an API method. For instance:\n *\n *     service Foo {\n *       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);\n *     }\n */\nexport interface Empty {\n}\n\nfunction createBaseEmpty(): Empty {\n  return {};\n}\n\nexport const Empty: MessageFns<Empty> = {\n  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Empty {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseEmpty();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(_: any): Empty {\n    return {};\n  },\n\n  toJSON(_: Empty): unknown {\n    const obj: any = {};\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {\n    return Empty.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {\n    const message = createBaseEmpty();\n    return message;\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\ntype DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\ntype Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\ninterface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  fromJSON(object: any): T;\n  toJSON(message: T): unknown;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n"],"names":["Empty","createBaseEmpty","encode","_","writer","BinaryWriter","decode","input","length","reader","BinaryReader","end","undefined","len","pos","message","tag","uint32","skip","fromJSON","toJSON","obj","create","base","fromPartial"],"mappings":"AAAA,sDAAsD;AACtD,YAAY;AACZ,gCAAgC;AAChC,iCAAiC;AACjC,sCAAsC;AAEtC,kBAAkB;;;;+BAmBLA;;;eAAAA;;;sBAlB8B;AAc3C,SAASC;IACP,OAAO,CAAC;AACV;AAEO,MAAMD,QAA2B;IACtCE,QAAOC,CAAQ,EAAEC,SAAuB,IAAIC,kBAAY,EAAE;QACxD,OAAOD;IACT;IAEAE,QAAOC,KAAgC,EAAEC,MAAe;QACtD,MAAMC,SAASF,iBAAiBG,kBAAY,GAAGH,QAAQ,IAAIG,kBAAY,CAACH;QACxE,IAAII,MAAMH,WAAWI,YAAYH,OAAOI,GAAG,GAAGJ,OAAOK,GAAG,GAAGN;QAC3D,MAAMO,UAAUd;QAChB,MAAOQ,OAAOK,GAAG,GAAGH,IAAK;YACvB,MAAMK,MAAMP,OAAOQ,MAAM;YACzB,OAAQD,QAAQ;YAChB;YACA,IAAI,AAACA,CAAAA,MAAM,CAAA,MAAO,KAAKA,QAAQ,GAAG;gBAChC;YACF;YACAP,OAAOS,IAAI,CAACF,MAAM;QACpB;QACA,OAAOD;IACT;IAEAI,UAAShB,CAAM;QACb,OAAO,CAAC;IACV;IAEAiB,QAAOjB,CAAQ;QACb,MAAMkB,MAAW,CAAC;QAClB,OAAOA;IACT;IAEAC,QAA+CC,IAAQ;QACrD,OAAOvB,MAAMwB,WAAW,CAACD,eAAAA,OAAS,CAAC;IACrC;IACAC,aAAoDrB,CAAI;QACtD,MAAMY,UAAUd;QAChB,OAAOc;IACT;AACF"}
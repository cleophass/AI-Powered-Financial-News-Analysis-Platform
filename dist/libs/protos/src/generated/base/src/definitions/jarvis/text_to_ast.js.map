{"version":3,"sources":["../../../../../../../../../libs/protos/src/generated/base/src/definitions/jarvis/text_to_ast.ts"],"sourcesContent":["// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.5.0\n//   protoc               v5.29.1\n// source: src/definitions/jarvis/text_to_ast.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\nimport {\n  type CallOptions,\n  ChannelCredentials,\n  Client,\n  type ClientOptions,\n  type ClientUnaryCall,\n  type handleUnaryCall,\n  makeGenericClientConstructor,\n  Metadata,\n  type ServiceError,\n  type UntypedServiceImplementation,\n} from \"@grpc/grpc-js\";\n\nexport interface ChatMessage {\n  role: string;\n  content: string;\n}\n\nexport interface TextToAstConversation {\n  messages: ChatMessage[];\n}\n\nfunction createBaseChatMessage(): ChatMessage {\n  return { role: \"\", content: \"\" };\n}\n\nexport const ChatMessage: MessageFns<ChatMessage> = {\n  encode(message: ChatMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.role !== \"\") {\n      writer.uint32(10).string(message.role);\n    }\n    if (message.content !== \"\") {\n      writer.uint32(18).string(message.content);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseChatMessage();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.role = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.content = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): ChatMessage {\n    return {\n      role: isSet(object.role) ? globalThis.String(object.role) : \"\",\n      content: isSet(object.content) ? globalThis.String(object.content) : \"\",\n    };\n  },\n\n  toJSON(message: ChatMessage): unknown {\n    const obj: any = {};\n    if (message.role !== \"\") {\n      obj.role = message.role;\n    }\n    if (message.content !== \"\") {\n      obj.content = message.content;\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<ChatMessage>, I>>(base?: I): ChatMessage {\n    return ChatMessage.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<ChatMessage>, I>>(object: I): ChatMessage {\n    const message = createBaseChatMessage();\n    message.role = object.role ?? \"\";\n    message.content = object.content ?? \"\";\n    return message;\n  },\n};\n\nfunction createBaseTextToAstConversation(): TextToAstConversation {\n  return { messages: [] };\n}\n\nexport const TextToAstConversation: MessageFns<TextToAstConversation> = {\n  encode(message: TextToAstConversation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    for (const v of message.messages) {\n      ChatMessage.encode(v!, writer.uint32(10).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): TextToAstConversation {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseTextToAstConversation();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.messages.push(ChatMessage.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  fromJSON(object: any): TextToAstConversation {\n    return {\n      messages: globalThis.Array.isArray(object?.messages)\n        ? object.messages.map((e: any) => ChatMessage.fromJSON(e))\n        : [],\n    };\n  },\n\n  toJSON(message: TextToAstConversation): unknown {\n    const obj: any = {};\n    if (message.messages?.length) {\n      obj.messages = message.messages.map((e) => ChatMessage.toJSON(e));\n    }\n    return obj;\n  },\n\n  create<I extends Exact<DeepPartial<TextToAstConversation>, I>>(base?: I): TextToAstConversation {\n    return TextToAstConversation.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<TextToAstConversation>, I>>(object: I): TextToAstConversation {\n    const message = createBaseTextToAstConversation();\n    message.messages = object.messages?.map((e) => ChatMessage.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nexport type TextToAstService = typeof TextToAstService;\nexport const TextToAstService = {\n  processText: {\n    path: \"/jarvis.TextToAst/ProcessText\",\n    requestStream: false,\n    responseStream: false,\n    requestSerialize: (value: TextToAstConversation) => Buffer.from(TextToAstConversation.encode(value).finish()),\n    requestDeserialize: (value: Buffer) => TextToAstConversation.decode(value),\n    responseSerialize: (value: TextToAstConversation) => Buffer.from(TextToAstConversation.encode(value).finish()),\n    responseDeserialize: (value: Buffer) => TextToAstConversation.decode(value),\n  },\n} as const;\n\nexport interface TextToAstServer extends UntypedServiceImplementation {\n  processText: handleUnaryCall<TextToAstConversation, TextToAstConversation>;\n}\n\nexport interface TextToAstClient extends Client {\n  processText(\n    request: TextToAstConversation,\n    callback: (error: ServiceError | null, response: TextToAstConversation) => void,\n  ): ClientUnaryCall;\n  processText(\n    request: TextToAstConversation,\n    metadata: Metadata,\n    callback: (error: ServiceError | null, response: TextToAstConversation) => void,\n  ): ClientUnaryCall;\n  processText(\n    request: TextToAstConversation,\n    metadata: Metadata,\n    options: Partial<CallOptions>,\n    callback: (error: ServiceError | null, response: TextToAstConversation) => void,\n  ): ClientUnaryCall;\n}\n\nexport const TextToAstClient = makeGenericClientConstructor(TextToAstService, \"jarvis.TextToAst\") as unknown as {\n  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): TextToAstClient;\n  service: typeof TextToAstService;\n  serviceName: string;\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\ntype DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\ntype Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\nfunction isSet(value: any): boolean {\n  return value !== null && value !== undefined;\n}\n\ninterface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  fromJSON(object: any): T;\n  toJSON(message: T): unknown;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n"],"names":["ChatMessage","TextToAstClient","TextToAstConversation","TextToAstService","createBaseChatMessage","role","content","encode","message","writer","BinaryWriter","uint32","string","decode","input","length","reader","BinaryReader","end","undefined","len","pos","tag","skip","fromJSON","object","isSet","globalThis","String","toJSON","obj","create","base","fromPartial","createBaseTextToAstConversation","messages","v","fork","join","push","Array","isArray","map","e","processText","path","requestStream","responseStream","requestSerialize","value","Buffer","from","finish","requestDeserialize","responseSerialize","responseDeserialize","makeGenericClientConstructor"],"mappings":"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"}
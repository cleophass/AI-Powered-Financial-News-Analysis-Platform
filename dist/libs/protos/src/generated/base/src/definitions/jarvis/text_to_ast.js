// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.5.0
//   protoc               v5.29.1
// source: src/definitions/jarvis/text_to_ast.proto
/* eslint-disable */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    ChatMessage: function() {
        return ChatMessage;
    },
    TextToAstClient: function() {
        return TextToAstClient;
    },
    TextToAstConversation: function() {
        return TextToAstConversation;
    },
    TextToAstService: function() {
        return TextToAstService;
    }
});
const _wire = require("@bufbuild/protobuf/wire");
const _grpcjs = require("@grpc/grpc-js");
function createBaseChatMessage() {
    return {
        role: "",
        content: ""
    };
}
const ChatMessage = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.role !== "") {
            writer.uint32(10).string(message.role);
        }
        if (message.content !== "") {
            writer.uint32(18).string(message.content);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseChatMessage();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.role = reader.string();
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.content = reader.string();
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            role: isSet(object.role) ? globalThis.String(object.role) : "",
            content: isSet(object.content) ? globalThis.String(object.content) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.role !== "") {
            obj.role = message.role;
        }
        if (message.content !== "") {
            obj.content = message.content;
        }
        return obj;
    },
    create (base) {
        return ChatMessage.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        const message = createBaseChatMessage();
        var _object_role;
        message.role = (_object_role = object.role) != null ? _object_role : "";
        var _object_content;
        message.content = (_object_content = object.content) != null ? _object_content : "";
        return message;
    }
};
function createBaseTextToAstConversation() {
    return {
        messages: []
    };
}
const TextToAstConversation = {
    encode (message, writer = new _wire.BinaryWriter()) {
        for (const v of message.messages){
            ChatMessage.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTextToAstConversation();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.messages.push(ChatMessage.decode(reader, reader.uint32()));
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            messages: globalThis.Array.isArray(object == null ? void 0 : object.messages) ? object.messages.map((e)=>ChatMessage.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        var _message_messages;
        const obj = {};
        if ((_message_messages = message.messages) == null ? void 0 : _message_messages.length) {
            obj.messages = message.messages.map((e)=>ChatMessage.toJSON(e));
        }
        return obj;
    },
    create (base) {
        return TextToAstConversation.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        var _object_messages;
        const message = createBaseTextToAstConversation();
        message.messages = ((_object_messages = object.messages) == null ? void 0 : _object_messages.map((e)=>ChatMessage.fromPartial(e))) || [];
        return message;
    }
};
const TextToAstService = {
    processText: {
        path: "/jarvis.TextToAst/ProcessText",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value)=>Buffer.from(TextToAstConversation.encode(value).finish()),
        requestDeserialize: (value)=>TextToAstConversation.decode(value),
        responseSerialize: (value)=>Buffer.from(TextToAstConversation.encode(value).finish()),
        responseDeserialize: (value)=>TextToAstConversation.decode(value)
    }
};
const TextToAstClient = (0, _grpcjs.makeGenericClientConstructor)(TextToAstService, "jarvis.TextToAst");
function isSet(value) {
    return value !== null && value !== undefined;
}

//# sourceMappingURL=text_to_ast.js.map
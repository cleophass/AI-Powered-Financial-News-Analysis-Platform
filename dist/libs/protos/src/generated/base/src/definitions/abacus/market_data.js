// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.5.0
//   protoc               v5.29.1
// source: src/definitions/abacus/market_data.proto
/* eslint-disable */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    Asset: function() {
        return Asset;
    },
    Candle: function() {
        return Candle;
    },
    ComputedIndicator: function() {
        return ComputedIndicator;
    },
    GetMarketDataRequest: function() {
        return GetMarketDataRequest;
    },
    GetRatesRequest: function() {
        return GetRatesRequest;
    },
    Indicator: function() {
        return Indicator;
    },
    IndicatorMetadata: function() {
        return IndicatorMetadata;
    },
    MarketDataClient: function() {
        return MarketDataClient;
    },
    MarketDataResponse: function() {
        return MarketDataResponse;
    },
    MarketDataService: function() {
        return MarketDataService;
    },
    Rate: function() {
        return Rate;
    },
    RatesResponse: function() {
        return RatesResponse;
    }
});
const _wire = require("@bufbuild/protobuf/wire");
const _grpcjs = require("@grpc/grpc-js");
const _struct = require("../../../google/protobuf/struct");
const _timestamp = require("../../../google/protobuf/timestamp");
function createBaseAsset() {
    return {
        base: "",
        broker: ""
    };
}
const Asset = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.base !== "") {
            writer.uint32(10).string(message.base);
        }
        if (message.broker !== "") {
            writer.uint32(18).string(message.broker);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAsset();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.base = reader.string();
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.broker = reader.string();
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            base: isSet(object.base) ? globalThis.String(object.base) : "",
            broker: isSet(object.broker) ? globalThis.String(object.broker) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.base !== "") {
            obj.base = message.base;
        }
        if (message.broker !== "") {
            obj.broker = message.broker;
        }
        return obj;
    },
    create (base) {
        return Asset.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        const message = createBaseAsset();
        var _object_base;
        message.base = (_object_base = object.base) != null ? _object_base : "";
        var _object_broker;
        message.broker = (_object_broker = object.broker) != null ? _object_broker : "";
        return message;
    }
};
function createBaseRate() {
    return {
        base: "",
        quote: "",
        broker: "",
        rate: 0
    };
}
const Rate = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.base !== "") {
            writer.uint32(10).string(message.base);
        }
        if (message.quote !== "") {
            writer.uint32(18).string(message.quote);
        }
        if (message.broker !== "") {
            writer.uint32(26).string(message.broker);
        }
        if (message.rate !== 0) {
            writer.uint32(33).double(message.rate);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRate();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.base = reader.string();
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.quote = reader.string();
                        continue;
                    }
                case 3:
                    {
                        if (tag !== 26) {
                            break;
                        }
                        message.broker = reader.string();
                        continue;
                    }
                case 4:
                    {
                        if (tag !== 33) {
                            break;
                        }
                        message.rate = reader.double();
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            base: isSet(object.base) ? globalThis.String(object.base) : "",
            quote: isSet(object.quote) ? globalThis.String(object.quote) : "",
            broker: isSet(object.broker) ? globalThis.String(object.broker) : "",
            rate: isSet(object.rate) ? globalThis.Number(object.rate) : 0
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.base !== "") {
            obj.base = message.base;
        }
        if (message.quote !== "") {
            obj.quote = message.quote;
        }
        if (message.broker !== "") {
            obj.broker = message.broker;
        }
        if (message.rate !== 0) {
            obj.rate = message.rate;
        }
        return obj;
    },
    create (base) {
        return Rate.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        const message = createBaseRate();
        var _object_base;
        message.base = (_object_base = object.base) != null ? _object_base : "";
        var _object_quote;
        message.quote = (_object_quote = object.quote) != null ? _object_quote : "";
        var _object_broker;
        message.broker = (_object_broker = object.broker) != null ? _object_broker : "";
        var _object_rate;
        message.rate = (_object_rate = object.rate) != null ? _object_rate : 0;
        return message;
    }
};
function createBaseIndicator() {
    return {
        name: "",
        parameters: undefined
    };
}
const Indicator = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.parameters !== undefined) {
            _struct.Struct.encode(_struct.Struct.wrap(message.parameters), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIndicator();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.name = reader.string();
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.parameters = _struct.Struct.unwrap(_struct.Struct.decode(reader, reader.uint32()));
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            parameters: isObject(object.parameters) ? object.parameters : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.parameters !== undefined) {
            obj.parameters = message.parameters;
        }
        return obj;
    },
    create (base) {
        return Indicator.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        const message = createBaseIndicator();
        var _object_name;
        message.name = (_object_name = object.name) != null ? _object_name : "";
        var _object_parameters;
        message.parameters = (_object_parameters = object.parameters) != null ? _object_parameters : undefined;
        return message;
    }
};
function createBaseIndicatorMetadata() {
    return {
        key: "",
        name: "",
        parameters: undefined
    };
}
const IndicatorMetadata = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.parameters !== undefined) {
            _struct.Struct.encode(_struct.Struct.wrap(message.parameters), writer.uint32(26).fork()).join();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIndicatorMetadata();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.key = reader.string();
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.name = reader.string();
                        continue;
                    }
                case 3:
                    {
                        if (tag !== 26) {
                            break;
                        }
                        message.parameters = _struct.Struct.unwrap(_struct.Struct.decode(reader, reader.uint32()));
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            parameters: isObject(object.parameters) ? object.parameters : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.parameters !== undefined) {
            obj.parameters = message.parameters;
        }
        return obj;
    },
    create (base) {
        return IndicatorMetadata.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        const message = createBaseIndicatorMetadata();
        var _object_key;
        message.key = (_object_key = object.key) != null ? _object_key : "";
        var _object_name;
        message.name = (_object_name = object.name) != null ? _object_name : "";
        var _object_parameters;
        message.parameters = (_object_parameters = object.parameters) != null ? _object_parameters : undefined;
        return message;
    }
};
function createBaseComputedIndicator() {
    return {
        key: "",
        outputs: undefined
    };
}
const ComputedIndicator = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.outputs !== undefined) {
            _struct.Struct.encode(_struct.Struct.wrap(message.outputs), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseComputedIndicator();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.key = reader.string();
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.outputs = _struct.Struct.unwrap(_struct.Struct.decode(reader, reader.uint32()));
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            outputs: isObject(object.outputs) ? object.outputs : undefined
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.outputs !== undefined) {
            obj.outputs = message.outputs;
        }
        return obj;
    },
    create (base) {
        return ComputedIndicator.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        const message = createBaseComputedIndicator();
        var _object_key;
        message.key = (_object_key = object.key) != null ? _object_key : "";
        var _object_outputs;
        message.outputs = (_object_outputs = object.outputs) != null ? _object_outputs : undefined;
        return message;
    }
};
function createBaseGetMarketDataRequest() {
    return {
        start: undefined,
        end: undefined,
        interval: "",
        base: "",
        quote: "",
        broker: "",
        indicators: []
    };
}
const GetMarketDataRequest = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.start !== undefined) {
            _timestamp.Timestamp.encode(toTimestamp(message.start), writer.uint32(10).fork()).join();
        }
        if (message.end !== undefined) {
            _timestamp.Timestamp.encode(toTimestamp(message.end), writer.uint32(18).fork()).join();
        }
        if (message.interval !== "") {
            writer.uint32(26).string(message.interval);
        }
        if (message.base !== "") {
            writer.uint32(34).string(message.base);
        }
        if (message.quote !== "") {
            writer.uint32(42).string(message.quote);
        }
        if (message.broker !== "") {
            writer.uint32(50).string(message.broker);
        }
        for (const v of message.indicators){
            Indicator.encode(v, writer.uint32(58).fork()).join();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetMarketDataRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.start = fromTimestamp(_timestamp.Timestamp.decode(reader, reader.uint32()));
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.end = fromTimestamp(_timestamp.Timestamp.decode(reader, reader.uint32()));
                        continue;
                    }
                case 3:
                    {
                        if (tag !== 26) {
                            break;
                        }
                        message.interval = reader.string();
                        continue;
                    }
                case 4:
                    {
                        if (tag !== 34) {
                            break;
                        }
                        message.base = reader.string();
                        continue;
                    }
                case 5:
                    {
                        if (tag !== 42) {
                            break;
                        }
                        message.quote = reader.string();
                        continue;
                    }
                case 6:
                    {
                        if (tag !== 50) {
                            break;
                        }
                        message.broker = reader.string();
                        continue;
                    }
                case 7:
                    {
                        if (tag !== 58) {
                            break;
                        }
                        message.indicators.push(Indicator.decode(reader, reader.uint32()));
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            start: isSet(object.start) ? fromJsonTimestamp(object.start) : undefined,
            end: isSet(object.end) ? fromJsonTimestamp(object.end) : undefined,
            interval: isSet(object.interval) ? globalThis.String(object.interval) : "",
            base: isSet(object.base) ? globalThis.String(object.base) : "",
            quote: isSet(object.quote) ? globalThis.String(object.quote) : "",
            broker: isSet(object.broker) ? globalThis.String(object.broker) : "",
            indicators: globalThis.Array.isArray(object == null ? void 0 : object.indicators) ? object.indicators.map((e)=>Indicator.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        var _message_indicators;
        const obj = {};
        if (message.start !== undefined) {
            obj.start = message.start.toISOString();
        }
        if (message.end !== undefined) {
            obj.end = message.end.toISOString();
        }
        if (message.interval !== "") {
            obj.interval = message.interval;
        }
        if (message.base !== "") {
            obj.base = message.base;
        }
        if (message.quote !== "") {
            obj.quote = message.quote;
        }
        if (message.broker !== "") {
            obj.broker = message.broker;
        }
        if ((_message_indicators = message.indicators) == null ? void 0 : _message_indicators.length) {
            obj.indicators = message.indicators.map((e)=>Indicator.toJSON(e));
        }
        return obj;
    },
    create (base) {
        return GetMarketDataRequest.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        var _object_indicators;
        const message = createBaseGetMarketDataRequest();
        var _object_start;
        message.start = (_object_start = object.start) != null ? _object_start : undefined;
        var _object_end;
        message.end = (_object_end = object.end) != null ? _object_end : undefined;
        var _object_interval;
        message.interval = (_object_interval = object.interval) != null ? _object_interval : "";
        var _object_base;
        message.base = (_object_base = object.base) != null ? _object_base : "";
        var _object_quote;
        message.quote = (_object_quote = object.quote) != null ? _object_quote : "";
        var _object_broker;
        message.broker = (_object_broker = object.broker) != null ? _object_broker : "";
        message.indicators = ((_object_indicators = object.indicators) == null ? void 0 : _object_indicators.map((e)=>Indicator.fromPartial(e))) || [];
        return message;
    }
};
function createBaseGetRatesRequest() {
    return {
        assets: [],
        quote: ""
    };
}
const GetRatesRequest = {
    encode (message, writer = new _wire.BinaryWriter()) {
        for (const v of message.assets){
            Asset.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.quote !== "") {
            writer.uint32(18).string(message.quote);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGetRatesRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.assets.push(Asset.decode(reader, reader.uint32()));
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.quote = reader.string();
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            assets: globalThis.Array.isArray(object == null ? void 0 : object.assets) ? object.assets.map((e)=>Asset.fromJSON(e)) : [],
            quote: isSet(object.quote) ? globalThis.String(object.quote) : ""
        };
    },
    toJSON (message) {
        var _message_assets;
        const obj = {};
        if ((_message_assets = message.assets) == null ? void 0 : _message_assets.length) {
            obj.assets = message.assets.map((e)=>Asset.toJSON(e));
        }
        if (message.quote !== "") {
            obj.quote = message.quote;
        }
        return obj;
    },
    create (base) {
        return GetRatesRequest.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        var _object_assets;
        const message = createBaseGetRatesRequest();
        message.assets = ((_object_assets = object.assets) == null ? void 0 : _object_assets.map((e)=>Asset.fromPartial(e))) || [];
        var _object_quote;
        message.quote = (_object_quote = object.quote) != null ? _object_quote : "";
        return message;
    }
};
function createBaseCandle() {
    return {
        openTime: undefined,
        closeTime: undefined,
        open: 0,
        high: 0,
        low: 0,
        close: 0,
        volume: 0,
        indicators: []
    };
}
const Candle = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.openTime !== undefined) {
            _timestamp.Timestamp.encode(toTimestamp(message.openTime), writer.uint32(10).fork()).join();
        }
        if (message.closeTime !== undefined) {
            _timestamp.Timestamp.encode(toTimestamp(message.closeTime), writer.uint32(18).fork()).join();
        }
        if (message.open !== 0) {
            writer.uint32(25).double(message.open);
        }
        if (message.high !== 0) {
            writer.uint32(33).double(message.high);
        }
        if (message.low !== 0) {
            writer.uint32(41).double(message.low);
        }
        if (message.close !== 0) {
            writer.uint32(49).double(message.close);
        }
        if (message.volume !== 0) {
            writer.uint32(57).double(message.volume);
        }
        for (const v of message.indicators){
            ComputedIndicator.encode(v, writer.uint32(66).fork()).join();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCandle();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.openTime = fromTimestamp(_timestamp.Timestamp.decode(reader, reader.uint32()));
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.closeTime = fromTimestamp(_timestamp.Timestamp.decode(reader, reader.uint32()));
                        continue;
                    }
                case 3:
                    {
                        if (tag !== 25) {
                            break;
                        }
                        message.open = reader.double();
                        continue;
                    }
                case 4:
                    {
                        if (tag !== 33) {
                            break;
                        }
                        message.high = reader.double();
                        continue;
                    }
                case 5:
                    {
                        if (tag !== 41) {
                            break;
                        }
                        message.low = reader.double();
                        continue;
                    }
                case 6:
                    {
                        if (tag !== 49) {
                            break;
                        }
                        message.close = reader.double();
                        continue;
                    }
                case 7:
                    {
                        if (tag !== 57) {
                            break;
                        }
                        message.volume = reader.double();
                        continue;
                    }
                case 8:
                    {
                        if (tag !== 66) {
                            break;
                        }
                        message.indicators.push(ComputedIndicator.decode(reader, reader.uint32()));
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            openTime: isSet(object.openTime) ? fromJsonTimestamp(object.openTime) : undefined,
            closeTime: isSet(object.closeTime) ? fromJsonTimestamp(object.closeTime) : undefined,
            open: isSet(object.open) ? globalThis.Number(object.open) : 0,
            high: isSet(object.high) ? globalThis.Number(object.high) : 0,
            low: isSet(object.low) ? globalThis.Number(object.low) : 0,
            close: isSet(object.close) ? globalThis.Number(object.close) : 0,
            volume: isSet(object.volume) ? globalThis.Number(object.volume) : 0,
            indicators: globalThis.Array.isArray(object == null ? void 0 : object.indicators) ? object.indicators.map((e)=>ComputedIndicator.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        var _message_indicators;
        const obj = {};
        if (message.openTime !== undefined) {
            obj.openTime = message.openTime.toISOString();
        }
        if (message.closeTime !== undefined) {
            obj.closeTime = message.closeTime.toISOString();
        }
        if (message.open !== 0) {
            obj.open = message.open;
        }
        if (message.high !== 0) {
            obj.high = message.high;
        }
        if (message.low !== 0) {
            obj.low = message.low;
        }
        if (message.close !== 0) {
            obj.close = message.close;
        }
        if (message.volume !== 0) {
            obj.volume = message.volume;
        }
        if ((_message_indicators = message.indicators) == null ? void 0 : _message_indicators.length) {
            obj.indicators = message.indicators.map((e)=>ComputedIndicator.toJSON(e));
        }
        return obj;
    },
    create (base) {
        return Candle.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        var _object_indicators;
        const message = createBaseCandle();
        var _object_openTime;
        message.openTime = (_object_openTime = object.openTime) != null ? _object_openTime : undefined;
        var _object_closeTime;
        message.closeTime = (_object_closeTime = object.closeTime) != null ? _object_closeTime : undefined;
        var _object_open;
        message.open = (_object_open = object.open) != null ? _object_open : 0;
        var _object_high;
        message.high = (_object_high = object.high) != null ? _object_high : 0;
        var _object_low;
        message.low = (_object_low = object.low) != null ? _object_low : 0;
        var _object_close;
        message.close = (_object_close = object.close) != null ? _object_close : 0;
        var _object_volume;
        message.volume = (_object_volume = object.volume) != null ? _object_volume : 0;
        message.indicators = ((_object_indicators = object.indicators) == null ? void 0 : _object_indicators.map((e)=>ComputedIndicator.fromPartial(e))) || [];
        return message;
    }
};
function createBaseMarketDataResponse() {
    return {
        indicators: [],
        candles: []
    };
}
const MarketDataResponse = {
    encode (message, writer = new _wire.BinaryWriter()) {
        for (const v of message.indicators){
            IndicatorMetadata.encode(v, writer.uint32(10).fork()).join();
        }
        for (const v of message.candles){
            Candle.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMarketDataResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.indicators.push(IndicatorMetadata.decode(reader, reader.uint32()));
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.candles.push(Candle.decode(reader, reader.uint32()));
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            indicators: globalThis.Array.isArray(object == null ? void 0 : object.indicators) ? object.indicators.map((e)=>IndicatorMetadata.fromJSON(e)) : [],
            candles: globalThis.Array.isArray(object == null ? void 0 : object.candles) ? object.candles.map((e)=>Candle.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        var _message_indicators, _message_candles;
        const obj = {};
        if ((_message_indicators = message.indicators) == null ? void 0 : _message_indicators.length) {
            obj.indicators = message.indicators.map((e)=>IndicatorMetadata.toJSON(e));
        }
        if ((_message_candles = message.candles) == null ? void 0 : _message_candles.length) {
            obj.candles = message.candles.map((e)=>Candle.toJSON(e));
        }
        return obj;
    },
    create (base) {
        return MarketDataResponse.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        var _object_indicators, _object_candles;
        const message = createBaseMarketDataResponse();
        message.indicators = ((_object_indicators = object.indicators) == null ? void 0 : _object_indicators.map((e)=>IndicatorMetadata.fromPartial(e))) || [];
        message.candles = ((_object_candles = object.candles) == null ? void 0 : _object_candles.map((e)=>Candle.fromPartial(e))) || [];
        return message;
    }
};
function createBaseRatesResponse() {
    return {
        time: undefined,
        rates: []
    };
}
const RatesResponse = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.time !== undefined) {
            _timestamp.Timestamp.encode(toTimestamp(message.time), writer.uint32(10).fork()).join();
        }
        for (const v of message.rates){
            Rate.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRatesResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.time = fromTimestamp(_timestamp.Timestamp.decode(reader, reader.uint32()));
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.rates.push(Rate.decode(reader, reader.uint32()));
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            time: isSet(object.time) ? fromJsonTimestamp(object.time) : undefined,
            rates: globalThis.Array.isArray(object == null ? void 0 : object.rates) ? object.rates.map((e)=>Rate.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        var _message_rates;
        const obj = {};
        if (message.time !== undefined) {
            obj.time = message.time.toISOString();
        }
        if ((_message_rates = message.rates) == null ? void 0 : _message_rates.length) {
            obj.rates = message.rates.map((e)=>Rate.toJSON(e));
        }
        return obj;
    },
    create (base) {
        return RatesResponse.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        var _object_rates;
        const message = createBaseRatesResponse();
        var _object_time;
        message.time = (_object_time = object.time) != null ? _object_time : undefined;
        message.rates = ((_object_rates = object.rates) == null ? void 0 : _object_rates.map((e)=>Rate.fromPartial(e))) || [];
        return message;
    }
};
const MarketDataService = {
    getMarketData: {
        path: "/abacus.MarketData/GetMarketData",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value)=>Buffer.from(GetMarketDataRequest.encode(value).finish()),
        requestDeserialize: (value)=>GetMarketDataRequest.decode(value),
        responseSerialize: (value)=>Buffer.from(MarketDataResponse.encode(value).finish()),
        responseDeserialize: (value)=>MarketDataResponse.decode(value)
    },
    getRates: {
        path: "/abacus.MarketData/GetRates",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value)=>Buffer.from(GetRatesRequest.encode(value).finish()),
        requestDeserialize: (value)=>GetRatesRequest.decode(value),
        responseSerialize: (value)=>Buffer.from(RatesResponse.encode(value).finish()),
        responseDeserialize: (value)=>RatesResponse.decode(value)
    }
};
const MarketDataClient = (0, _grpcjs.makeGenericClientConstructor)(MarketDataService, "abacus.MarketData");
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = date.getTime() % 1000 * 1000000;
    return {
        seconds,
        nanos
    };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    } else if (typeof o === "string") {
        return new globalThis.Date(o);
    } else {
        return fromTimestamp(_timestamp.Timestamp.fromJSON(o));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}

//# sourceMappingURL=market_data.js.map
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.5.0
//   protoc               v5.29.1
// source: src/definitions/minerva/backtests.proto
/* eslint-disable */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    BacktestByIdRequest: function() {
        return BacktestByIdRequest;
    },
    BacktestResponse: function() {
        return BacktestResponse;
    },
    BacktestsByFlowIdRequest: function() {
        return BacktestsByFlowIdRequest;
    },
    BacktestsByStrategyIdRequest: function() {
        return BacktestsByStrategyIdRequest;
    },
    BacktestsByUserIdRequest: function() {
        return BacktestsByUserIdRequest;
    },
    BacktestsClient: function() {
        return BacktestsClient;
    },
    BacktestsListResponse: function() {
        return BacktestsListResponse;
    },
    BacktestsService: function() {
        return BacktestsService;
    },
    CreateBacktestRequest: function() {
        return CreateBacktestRequest;
    },
    UpdateBacktestRequest: function() {
        return UpdateBacktestRequest;
    }
});
const _wire = require("@bufbuild/protobuf/wire");
const _grpcjs = require("@grpc/grpc-js");
const _struct = require("../../../google/protobuf/struct");
const _timestamp = require("../../../google/protobuf/timestamp");
function createBaseBacktestResponse() {
    return {
        id: "",
        startDate: undefined,
        baseBudget: 0,
        frequency: "",
        runIfOrdersActive: false,
        base: "",
        quote: "",
        broker: "",
        createdAt: undefined,
        updatedAt: undefined,
        finishedAt: undefined,
        isFinished: false,
        trades: [],
        errors: [],
        metrics: undefined
    };
}
const BacktestResponse = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.startDate !== undefined) {
            _timestamp.Timestamp.encode(toTimestamp(message.startDate), writer.uint32(18).fork()).join();
        }
        if (message.baseBudget !== 0) {
            writer.uint32(25).double(message.baseBudget);
        }
        if (message.frequency !== "") {
            writer.uint32(34).string(message.frequency);
        }
        if (message.runIfOrdersActive !== false) {
            writer.uint32(40).bool(message.runIfOrdersActive);
        }
        if (message.base !== "") {
            writer.uint32(50).string(message.base);
        }
        if (message.quote !== "") {
            writer.uint32(58).string(message.quote);
        }
        if (message.broker !== "") {
            writer.uint32(66).string(message.broker);
        }
        if (message.createdAt !== undefined) {
            _timestamp.Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(74).fork()).join();
        }
        if (message.updatedAt !== undefined) {
            _timestamp.Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(82).fork()).join();
        }
        if (message.finishedAt !== undefined) {
            _timestamp.Timestamp.encode(toTimestamp(message.finishedAt), writer.uint32(90).fork()).join();
        }
        if (message.isFinished !== false) {
            writer.uint32(96).bool(message.isFinished);
        }
        for (const v of message.trades){
            _struct.Struct.encode(_struct.Struct.wrap(v), writer.uint32(106).fork()).join();
        }
        for (const v of message.errors){
            _struct.Struct.encode(_struct.Struct.wrap(v), writer.uint32(114).fork()).join();
        }
        if (message.metrics !== undefined) {
            _struct.Struct.encode(_struct.Struct.wrap(message.metrics), writer.uint32(122).fork()).join();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBacktestResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.id = reader.string();
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.startDate = fromTimestamp(_timestamp.Timestamp.decode(reader, reader.uint32()));
                        continue;
                    }
                case 3:
                    {
                        if (tag !== 25) {
                            break;
                        }
                        message.baseBudget = reader.double();
                        continue;
                    }
                case 4:
                    {
                        if (tag !== 34) {
                            break;
                        }
                        message.frequency = reader.string();
                        continue;
                    }
                case 5:
                    {
                        if (tag !== 40) {
                            break;
                        }
                        message.runIfOrdersActive = reader.bool();
                        continue;
                    }
                case 6:
                    {
                        if (tag !== 50) {
                            break;
                        }
                        message.base = reader.string();
                        continue;
                    }
                case 7:
                    {
                        if (tag !== 58) {
                            break;
                        }
                        message.quote = reader.string();
                        continue;
                    }
                case 8:
                    {
                        if (tag !== 66) {
                            break;
                        }
                        message.broker = reader.string();
                        continue;
                    }
                case 9:
                    {
                        if (tag !== 74) {
                            break;
                        }
                        message.createdAt = fromTimestamp(_timestamp.Timestamp.decode(reader, reader.uint32()));
                        continue;
                    }
                case 10:
                    {
                        if (tag !== 82) {
                            break;
                        }
                        message.updatedAt = fromTimestamp(_timestamp.Timestamp.decode(reader, reader.uint32()));
                        continue;
                    }
                case 11:
                    {
                        if (tag !== 90) {
                            break;
                        }
                        message.finishedAt = fromTimestamp(_timestamp.Timestamp.decode(reader, reader.uint32()));
                        continue;
                    }
                case 12:
                    {
                        if (tag !== 96) {
                            break;
                        }
                        message.isFinished = reader.bool();
                        continue;
                    }
                case 13:
                    {
                        if (tag !== 106) {
                            break;
                        }
                        message.trades.push(_struct.Struct.unwrap(_struct.Struct.decode(reader, reader.uint32())));
                        continue;
                    }
                case 14:
                    {
                        if (tag !== 114) {
                            break;
                        }
                        message.errors.push(_struct.Struct.unwrap(_struct.Struct.decode(reader, reader.uint32())));
                        continue;
                    }
                case 15:
                    {
                        if (tag !== 122) {
                            break;
                        }
                        message.metrics = _struct.Struct.unwrap(_struct.Struct.decode(reader, reader.uint32()));
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            startDate: isSet(object.startDate) ? fromJsonTimestamp(object.startDate) : undefined,
            baseBudget: isSet(object.baseBudget) ? globalThis.Number(object.baseBudget) : 0,
            frequency: isSet(object.frequency) ? globalThis.String(object.frequency) : "",
            runIfOrdersActive: isSet(object.runIfOrdersActive) ? globalThis.Boolean(object.runIfOrdersActive) : false,
            base: isSet(object.base) ? globalThis.String(object.base) : "",
            quote: isSet(object.quote) ? globalThis.String(object.quote) : "",
            broker: isSet(object.broker) ? globalThis.String(object.broker) : "",
            createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
            updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
            finishedAt: isSet(object.finishedAt) ? fromJsonTimestamp(object.finishedAt) : undefined,
            isFinished: isSet(object.isFinished) ? globalThis.Boolean(object.isFinished) : false,
            trades: globalThis.Array.isArray(object == null ? void 0 : object.trades) ? [
                ...object.trades
            ] : [],
            errors: globalThis.Array.isArray(object == null ? void 0 : object.errors) ? [
                ...object.errors
            ] : [],
            metrics: isObject(object.metrics) ? object.metrics : undefined
        };
    },
    toJSON (message) {
        var _message_trades, _message_errors;
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.startDate !== undefined) {
            obj.startDate = message.startDate.toISOString();
        }
        if (message.baseBudget !== 0) {
            obj.baseBudget = message.baseBudget;
        }
        if (message.frequency !== "") {
            obj.frequency = message.frequency;
        }
        if (message.runIfOrdersActive !== false) {
            obj.runIfOrdersActive = message.runIfOrdersActive;
        }
        if (message.base !== "") {
            obj.base = message.base;
        }
        if (message.quote !== "") {
            obj.quote = message.quote;
        }
        if (message.broker !== "") {
            obj.broker = message.broker;
        }
        if (message.createdAt !== undefined) {
            obj.createdAt = message.createdAt.toISOString();
        }
        if (message.updatedAt !== undefined) {
            obj.updatedAt = message.updatedAt.toISOString();
        }
        if (message.finishedAt !== undefined) {
            obj.finishedAt = message.finishedAt.toISOString();
        }
        if (message.isFinished !== false) {
            obj.isFinished = message.isFinished;
        }
        if ((_message_trades = message.trades) == null ? void 0 : _message_trades.length) {
            obj.trades = message.trades;
        }
        if ((_message_errors = message.errors) == null ? void 0 : _message_errors.length) {
            obj.errors = message.errors;
        }
        if (message.metrics !== undefined) {
            obj.metrics = message.metrics;
        }
        return obj;
    },
    create (base) {
        return BacktestResponse.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        var _object_trades, _object_errors;
        const message = createBaseBacktestResponse();
        var _object_id;
        message.id = (_object_id = object.id) != null ? _object_id : "";
        var _object_startDate;
        message.startDate = (_object_startDate = object.startDate) != null ? _object_startDate : undefined;
        var _object_baseBudget;
        message.baseBudget = (_object_baseBudget = object.baseBudget) != null ? _object_baseBudget : 0;
        var _object_frequency;
        message.frequency = (_object_frequency = object.frequency) != null ? _object_frequency : "";
        var _object_runIfOrdersActive;
        message.runIfOrdersActive = (_object_runIfOrdersActive = object.runIfOrdersActive) != null ? _object_runIfOrdersActive : false;
        var _object_base;
        message.base = (_object_base = object.base) != null ? _object_base : "";
        var _object_quote;
        message.quote = (_object_quote = object.quote) != null ? _object_quote : "";
        var _object_broker;
        message.broker = (_object_broker = object.broker) != null ? _object_broker : "";
        var _object_createdAt;
        message.createdAt = (_object_createdAt = object.createdAt) != null ? _object_createdAt : undefined;
        var _object_updatedAt;
        message.updatedAt = (_object_updatedAt = object.updatedAt) != null ? _object_updatedAt : undefined;
        var _object_finishedAt;
        message.finishedAt = (_object_finishedAt = object.finishedAt) != null ? _object_finishedAt : undefined;
        var _object_isFinished;
        message.isFinished = (_object_isFinished = object.isFinished) != null ? _object_isFinished : false;
        message.trades = ((_object_trades = object.trades) == null ? void 0 : _object_trades.map((e)=>e)) || [];
        message.errors = ((_object_errors = object.errors) == null ? void 0 : _object_errors.map((e)=>e)) || [];
        var _object_metrics;
        message.metrics = (_object_metrics = object.metrics) != null ? _object_metrics : undefined;
        return message;
    }
};
function createBaseBacktestsListResponse() {
    return {
        backtests: []
    };
}
const BacktestsListResponse = {
    encode (message, writer = new _wire.BinaryWriter()) {
        for (const v of message.backtests){
            BacktestResponse.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBacktestsListResponse();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.backtests.push(BacktestResponse.decode(reader, reader.uint32()));
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            backtests: globalThis.Array.isArray(object == null ? void 0 : object.backtests) ? object.backtests.map((e)=>BacktestResponse.fromJSON(e)) : []
        };
    },
    toJSON (message) {
        var _message_backtests;
        const obj = {};
        if ((_message_backtests = message.backtests) == null ? void 0 : _message_backtests.length) {
            obj.backtests = message.backtests.map((e)=>BacktestResponse.toJSON(e));
        }
        return obj;
    },
    create (base) {
        return BacktestsListResponse.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        var _object_backtests;
        const message = createBaseBacktestsListResponse();
        message.backtests = ((_object_backtests = object.backtests) == null ? void 0 : _object_backtests.map((e)=>BacktestResponse.fromPartial(e))) || [];
        return message;
    }
};
function createBaseBacktestByIdRequest() {
    return {
        userId: "",
        id: ""
    };
}
const BacktestByIdRequest = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBacktestByIdRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.userId = reader.string();
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.id = reader.string();
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
            id: isSet(object.id) ? globalThis.String(object.id) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        if (message.id !== "") {
            obj.id = message.id;
        }
        return obj;
    },
    create (base) {
        return BacktestByIdRequest.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        const message = createBaseBacktestByIdRequest();
        var _object_userId;
        message.userId = (_object_userId = object.userId) != null ? _object_userId : "";
        var _object_id;
        message.id = (_object_id = object.id) != null ? _object_id : "";
        return message;
    }
};
function createBaseBacktestsByFlowIdRequest() {
    return {
        userId: "",
        flowId: ""
    };
}
const BacktestsByFlowIdRequest = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        if (message.flowId !== "") {
            writer.uint32(18).string(message.flowId);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBacktestsByFlowIdRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.userId = reader.string();
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.flowId = reader.string();
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
            flowId: isSet(object.flowId) ? globalThis.String(object.flowId) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        if (message.flowId !== "") {
            obj.flowId = message.flowId;
        }
        return obj;
    },
    create (base) {
        return BacktestsByFlowIdRequest.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        const message = createBaseBacktestsByFlowIdRequest();
        var _object_userId;
        message.userId = (_object_userId = object.userId) != null ? _object_userId : "";
        var _object_flowId;
        message.flowId = (_object_flowId = object.flowId) != null ? _object_flowId : "";
        return message;
    }
};
function createBaseBacktestsByStrategyIdRequest() {
    return {
        userId: "",
        strategyId: ""
    };
}
const BacktestsByStrategyIdRequest = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        if (message.strategyId !== "") {
            writer.uint32(18).string(message.strategyId);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBacktestsByStrategyIdRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.userId = reader.string();
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.strategyId = reader.string();
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
            strategyId: isSet(object.strategyId) ? globalThis.String(object.strategyId) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        if (message.strategyId !== "") {
            obj.strategyId = message.strategyId;
        }
        return obj;
    },
    create (base) {
        return BacktestsByStrategyIdRequest.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        const message = createBaseBacktestsByStrategyIdRequest();
        var _object_userId;
        message.userId = (_object_userId = object.userId) != null ? _object_userId : "";
        var _object_strategyId;
        message.strategyId = (_object_strategyId = object.strategyId) != null ? _object_strategyId : "";
        return message;
    }
};
function createBaseBacktestsByUserIdRequest() {
    return {
        userId: ""
    };
}
const BacktestsByUserIdRequest = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBacktestsByUserIdRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.userId = reader.string();
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            userId: isSet(object.userId) ? globalThis.String(object.userId) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        return obj;
    },
    create (base) {
        return BacktestsByUserIdRequest.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        const message = createBaseBacktestsByUserIdRequest();
        var _object_userId;
        message.userId = (_object_userId = object.userId) != null ? _object_userId : "";
        return message;
    }
};
function createBaseCreateBacktestRequest() {
    return {
        userId: "",
        flowId: "",
        startDate: undefined,
        endDate: undefined,
        baseBudget: 0,
        frequency: "",
        runIfOrdersActive: false,
        base: "",
        quote: "",
        broker: ""
    };
}
const CreateBacktestRequest = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        if (message.flowId !== "") {
            writer.uint32(18).string(message.flowId);
        }
        if (message.startDate !== undefined) {
            _timestamp.Timestamp.encode(toTimestamp(message.startDate), writer.uint32(26).fork()).join();
        }
        if (message.endDate !== undefined) {
            _timestamp.Timestamp.encode(toTimestamp(message.endDate), writer.uint32(34).fork()).join();
        }
        if (message.baseBudget !== 0) {
            writer.uint32(41).double(message.baseBudget);
        }
        if (message.frequency !== "") {
            writer.uint32(50).string(message.frequency);
        }
        if (message.runIfOrdersActive !== false) {
            writer.uint32(56).bool(message.runIfOrdersActive);
        }
        if (message.base !== "") {
            writer.uint32(66).string(message.base);
        }
        if (message.quote !== "") {
            writer.uint32(74).string(message.quote);
        }
        if (message.broker !== "") {
            writer.uint32(82).string(message.broker);
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateBacktestRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.userId = reader.string();
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.flowId = reader.string();
                        continue;
                    }
                case 3:
                    {
                        if (tag !== 26) {
                            break;
                        }
                        message.startDate = fromTimestamp(_timestamp.Timestamp.decode(reader, reader.uint32()));
                        continue;
                    }
                case 4:
                    {
                        if (tag !== 34) {
                            break;
                        }
                        message.endDate = fromTimestamp(_timestamp.Timestamp.decode(reader, reader.uint32()));
                        continue;
                    }
                case 5:
                    {
                        if (tag !== 41) {
                            break;
                        }
                        message.baseBudget = reader.double();
                        continue;
                    }
                case 6:
                    {
                        if (tag !== 50) {
                            break;
                        }
                        message.frequency = reader.string();
                        continue;
                    }
                case 7:
                    {
                        if (tag !== 56) {
                            break;
                        }
                        message.runIfOrdersActive = reader.bool();
                        continue;
                    }
                case 8:
                    {
                        if (tag !== 66) {
                            break;
                        }
                        message.base = reader.string();
                        continue;
                    }
                case 9:
                    {
                        if (tag !== 74) {
                            break;
                        }
                        message.quote = reader.string();
                        continue;
                    }
                case 10:
                    {
                        if (tag !== 82) {
                            break;
                        }
                        message.broker = reader.string();
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
            flowId: isSet(object.flowId) ? globalThis.String(object.flowId) : "",
            startDate: isSet(object.startDate) ? fromJsonTimestamp(object.startDate) : undefined,
            endDate: isSet(object.endDate) ? fromJsonTimestamp(object.endDate) : undefined,
            baseBudget: isSet(object.baseBudget) ? globalThis.Number(object.baseBudget) : 0,
            frequency: isSet(object.frequency) ? globalThis.String(object.frequency) : "",
            runIfOrdersActive: isSet(object.runIfOrdersActive) ? globalThis.Boolean(object.runIfOrdersActive) : false,
            base: isSet(object.base) ? globalThis.String(object.base) : "",
            quote: isSet(object.quote) ? globalThis.String(object.quote) : "",
            broker: isSet(object.broker) ? globalThis.String(object.broker) : ""
        };
    },
    toJSON (message) {
        const obj = {};
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        if (message.flowId !== "") {
            obj.flowId = message.flowId;
        }
        if (message.startDate !== undefined) {
            obj.startDate = message.startDate.toISOString();
        }
        if (message.endDate !== undefined) {
            obj.endDate = message.endDate.toISOString();
        }
        if (message.baseBudget !== 0) {
            obj.baseBudget = message.baseBudget;
        }
        if (message.frequency !== "") {
            obj.frequency = message.frequency;
        }
        if (message.runIfOrdersActive !== false) {
            obj.runIfOrdersActive = message.runIfOrdersActive;
        }
        if (message.base !== "") {
            obj.base = message.base;
        }
        if (message.quote !== "") {
            obj.quote = message.quote;
        }
        if (message.broker !== "") {
            obj.broker = message.broker;
        }
        return obj;
    },
    create (base) {
        return CreateBacktestRequest.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        const message = createBaseCreateBacktestRequest();
        var _object_userId;
        message.userId = (_object_userId = object.userId) != null ? _object_userId : "";
        var _object_flowId;
        message.flowId = (_object_flowId = object.flowId) != null ? _object_flowId : "";
        var _object_startDate;
        message.startDate = (_object_startDate = object.startDate) != null ? _object_startDate : undefined;
        var _object_endDate;
        message.endDate = (_object_endDate = object.endDate) != null ? _object_endDate : undefined;
        var _object_baseBudget;
        message.baseBudget = (_object_baseBudget = object.baseBudget) != null ? _object_baseBudget : 0;
        var _object_frequency;
        message.frequency = (_object_frequency = object.frequency) != null ? _object_frequency : "";
        var _object_runIfOrdersActive;
        message.runIfOrdersActive = (_object_runIfOrdersActive = object.runIfOrdersActive) != null ? _object_runIfOrdersActive : false;
        var _object_base;
        message.base = (_object_base = object.base) != null ? _object_base : "";
        var _object_quote;
        message.quote = (_object_quote = object.quote) != null ? _object_quote : "";
        var _object_broker;
        message.broker = (_object_broker = object.broker) != null ? _object_broker : "";
        return message;
    }
};
function createBaseUpdateBacktestRequest() {
    return {
        id: "",
        userId: "",
        finishedAt: undefined,
        trades: [],
        errors: [],
        metrics: undefined
    };
}
const UpdateBacktestRequest = {
    encode (message, writer = new _wire.BinaryWriter()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.userId !== "") {
            writer.uint32(18).string(message.userId);
        }
        if (message.finishedAt !== undefined) {
            _timestamp.Timestamp.encode(toTimestamp(message.finishedAt), writer.uint32(26).fork()).join();
        }
        for (const v of message.trades){
            _struct.Struct.encode(_struct.Struct.wrap(v), writer.uint32(34).fork()).join();
        }
        for (const v of message.errors){
            _struct.Struct.encode(_struct.Struct.wrap(v), writer.uint32(42).fork()).join();
        }
        if (message.metrics !== undefined) {
            _struct.Struct.encode(_struct.Struct.wrap(message.metrics), writer.uint32(50).fork()).join();
        }
        return writer;
    },
    decode (input, length) {
        const reader = input instanceof _wire.BinaryReader ? input : new _wire.BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUpdateBacktestRequest();
        while(reader.pos < end){
            const tag = reader.uint32();
            switch(tag >>> 3){
                case 1:
                    {
                        if (tag !== 10) {
                            break;
                        }
                        message.id = reader.string();
                        continue;
                    }
                case 2:
                    {
                        if (tag !== 18) {
                            break;
                        }
                        message.userId = reader.string();
                        continue;
                    }
                case 3:
                    {
                        if (tag !== 26) {
                            break;
                        }
                        message.finishedAt = fromTimestamp(_timestamp.Timestamp.decode(reader, reader.uint32()));
                        continue;
                    }
                case 4:
                    {
                        if (tag !== 34) {
                            break;
                        }
                        message.trades.push(_struct.Struct.unwrap(_struct.Struct.decode(reader, reader.uint32())));
                        continue;
                    }
                case 5:
                    {
                        if (tag !== 42) {
                            break;
                        }
                        message.errors.push(_struct.Struct.unwrap(_struct.Struct.decode(reader, reader.uint32())));
                        continue;
                    }
                case 6:
                    {
                        if (tag !== 50) {
                            break;
                        }
                        message.metrics = _struct.Struct.unwrap(_struct.Struct.decode(reader, reader.uint32()));
                        continue;
                    }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON (object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
            finishedAt: isSet(object.finishedAt) ? fromJsonTimestamp(object.finishedAt) : undefined,
            trades: globalThis.Array.isArray(object == null ? void 0 : object.trades) ? [
                ...object.trades
            ] : [],
            errors: globalThis.Array.isArray(object == null ? void 0 : object.errors) ? [
                ...object.errors
            ] : [],
            metrics: isObject(object.metrics) ? object.metrics : undefined
        };
    },
    toJSON (message) {
        var _message_trades, _message_errors;
        const obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        if (message.finishedAt !== undefined) {
            obj.finishedAt = message.finishedAt.toISOString();
        }
        if ((_message_trades = message.trades) == null ? void 0 : _message_trades.length) {
            obj.trades = message.trades;
        }
        if ((_message_errors = message.errors) == null ? void 0 : _message_errors.length) {
            obj.errors = message.errors;
        }
        if (message.metrics !== undefined) {
            obj.metrics = message.metrics;
        }
        return obj;
    },
    create (base) {
        return UpdateBacktestRequest.fromPartial(base != null ? base : {});
    },
    fromPartial (object) {
        var _object_trades, _object_errors;
        const message = createBaseUpdateBacktestRequest();
        var _object_id;
        message.id = (_object_id = object.id) != null ? _object_id : "";
        var _object_userId;
        message.userId = (_object_userId = object.userId) != null ? _object_userId : "";
        var _object_finishedAt;
        message.finishedAt = (_object_finishedAt = object.finishedAt) != null ? _object_finishedAt : undefined;
        message.trades = ((_object_trades = object.trades) == null ? void 0 : _object_trades.map((e)=>e)) || [];
        message.errors = ((_object_errors = object.errors) == null ? void 0 : _object_errors.map((e)=>e)) || [];
        var _object_metrics;
        message.metrics = (_object_metrics = object.metrics) != null ? _object_metrics : undefined;
        return message;
    }
};
const BacktestsService = {
    createBacktest: {
        path: "/minerva.Backtests/CreateBacktest",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value)=>Buffer.from(CreateBacktestRequest.encode(value).finish()),
        requestDeserialize: (value)=>CreateBacktestRequest.decode(value),
        responseSerialize: (value)=>Buffer.from(BacktestResponse.encode(value).finish()),
        responseDeserialize: (value)=>BacktestResponse.decode(value)
    },
    updateBacktest: {
        path: "/minerva.Backtests/UpdateBacktest",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value)=>Buffer.from(UpdateBacktestRequest.encode(value).finish()),
        requestDeserialize: (value)=>UpdateBacktestRequest.decode(value),
        responseSerialize: (value)=>Buffer.from(BacktestResponse.encode(value).finish()),
        responseDeserialize: (value)=>BacktestResponse.decode(value)
    },
    getBacktestById: {
        path: "/minerva.Backtests/GetBacktestById",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value)=>Buffer.from(BacktestByIdRequest.encode(value).finish()),
        requestDeserialize: (value)=>BacktestByIdRequest.decode(value),
        responseSerialize: (value)=>Buffer.from(BacktestResponse.encode(value).finish()),
        responseDeserialize: (value)=>BacktestResponse.decode(value)
    },
    listBacktestsByFlowId: {
        path: "/minerva.Backtests/ListBacktestsByFlowId",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value)=>Buffer.from(BacktestsByFlowIdRequest.encode(value).finish()),
        requestDeserialize: (value)=>BacktestsByFlowIdRequest.decode(value),
        responseSerialize: (value)=>Buffer.from(BacktestsListResponse.encode(value).finish()),
        responseDeserialize: (value)=>BacktestsListResponse.decode(value)
    },
    listBacktestsByStrategyId: {
        path: "/minerva.Backtests/ListBacktestsByStrategyId",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value)=>Buffer.from(BacktestsByStrategyIdRequest.encode(value).finish()),
        requestDeserialize: (value)=>BacktestsByStrategyIdRequest.decode(value),
        responseSerialize: (value)=>Buffer.from(BacktestsListResponse.encode(value).finish()),
        responseDeserialize: (value)=>BacktestsListResponse.decode(value)
    },
    listBacktestsByUserId: {
        path: "/minerva.Backtests/ListBacktestsByUserId",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value)=>Buffer.from(BacktestsByUserIdRequest.encode(value).finish()),
        requestDeserialize: (value)=>BacktestsByUserIdRequest.decode(value),
        responseSerialize: (value)=>Buffer.from(BacktestsListResponse.encode(value).finish()),
        responseDeserialize: (value)=>BacktestsListResponse.decode(value)
    }
};
const BacktestsClient = (0, _grpcjs.makeGenericClientConstructor)(BacktestsService, "minerva.Backtests");
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = date.getTime() % 1000 * 1000000;
    return {
        seconds,
        nanos
    };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return o;
    } else if (typeof o === "string") {
        return new globalThis.Date(o);
    } else {
        return fromTimestamp(_timestamp.Timestamp.fromJSON(o));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}

//# sourceMappingURL=backtests.js.map
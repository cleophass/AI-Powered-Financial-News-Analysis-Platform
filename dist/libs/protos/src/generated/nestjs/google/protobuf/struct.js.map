{"version":3,"sources":["../../../../../../../../libs/protos/src/generated/nestjs/google/protobuf/struct.ts"],"sourcesContent":["// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.5.0\n//   protoc               v5.29.1\n// source: google/protobuf/struct.proto\n\n/* eslint-disable */\nimport { wrappers } from \"protobufjs\";\n\n/**\n * `NullValue` is a singleton enumeration to represent the null value for the\n * `Value` type union.\n *\n * The JSON representation for `NullValue` is JSON `null`.\n */\nexport enum NullValue {\n  /** NULL_VALUE - Null value. */\n  NULL_VALUE = 0,\n  UNRECOGNIZED = -1,\n}\n\n/**\n * `Struct` represents a structured data value, consisting of fields\n * which map to dynamically typed values. In some languages, `Struct`\n * might be supported by a native representation. For example, in\n * scripting languages like JS a struct is represented as an\n * object. The details of that representation are described together\n * with the proto support for the language.\n *\n * The JSON representation for `Struct` is JSON object.\n */\nexport interface Struct {\n  /** Unordered map of dynamically typed values. */\n  fields: { [key: string]: any | undefined };\n}\n\nexport interface Struct_FieldsEntry {\n  key: string;\n  value: any | undefined;\n}\n\n/**\n * `Value` represents a dynamically typed value which can be either\n * null, a number, a string, a boolean, a recursive struct value, or a\n * list of values. A producer of value is expected to set one of these\n * variants. Absence of any variant indicates an error.\n *\n * The JSON representation for `Value` is JSON value.\n */\nexport interface Value {\n  /** Represents a null value. */\n  nullValue?:\n    | NullValue\n    | undefined;\n  /** Represents a double value. */\n  numberValue?:\n    | number\n    | undefined;\n  /** Represents a string value. */\n  stringValue?:\n    | string\n    | undefined;\n  /** Represents a boolean value. */\n  boolValue?:\n    | boolean\n    | undefined;\n  /** Represents a structured value. */\n  structValue?:\n    | { [key: string]: any }\n    | undefined;\n  /** Represents a repeated `Value`. */\n  listValue?: Array<any> | undefined;\n}\n\n/**\n * `ListValue` is a wrapper around a repeated field of values.\n *\n * The JSON representation for `ListValue` is JSON array.\n */\nexport interface ListValue {\n  /** Repeated field of dynamically typed values. */\n  values: any[];\n}\n\nfunction createBaseStruct(): Struct {\n  return { fields: {} };\n}\n\nexport const Struct: MessageFns<Struct> & StructWrapperFns = {\n  wrap(object: { [key: string]: any } | undefined): Struct {\n    const struct = createBaseStruct();\n\n    if (object !== undefined) {\n      for (const key of Object.keys(object)) {\n        struct.fields[key] = Value.wrap(object[key]);\n      }\n    }\n    return struct;\n  },\n\n  unwrap(message: Struct): { [key: string]: any } {\n    const object: { [key: string]: any } = {};\n    if (message.fields) {\n      for (const key of Object.keys(message.fields)) {\n        object[key] = Value.unwrap(message.fields[key]);\n      }\n    }\n    return object;\n  },\n};\n\nfunction createBaseValue(): Value {\n  return {};\n}\n\nexport const Value: MessageFns<Value> & AnyValueWrapperFns = {\n  wrap(value: any): Value {\n    const result = {} as any;\n    if (value === null) {\n      result.nullValue = NullValue.NULL_VALUE;\n    } else if (typeof value === \"boolean\") {\n      result.boolValue = value;\n    } else if (typeof value === \"number\") {\n      result.numberValue = value;\n    } else if (typeof value === \"string\") {\n      result.stringValue = value;\n    } else if (globalThis.Array.isArray(value)) {\n      result.listValue = ListValue.wrap(value);\n    } else if (typeof value === \"object\") {\n      result.structValue = Struct.wrap(value);\n    } else if (typeof value !== \"undefined\") {\n      throw new globalThis.Error(\"Unsupported any value type: \" + typeof value);\n    }\n    return result;\n  },\n\n  unwrap(message: any): string | number | boolean | Object | null | Array<any> | undefined {\n    if (message?.hasOwnProperty(\"stringValue\") && message.stringValue !== undefined) {\n      return message.stringValue;\n    } else if (message?.hasOwnProperty(\"numberValue\") && message?.numberValue !== undefined) {\n      return message.numberValue;\n    } else if (message?.hasOwnProperty(\"boolValue\") && message?.boolValue !== undefined) {\n      return message.boolValue;\n    } else if (message?.hasOwnProperty(\"structValue\") && message?.structValue !== undefined) {\n      return Struct.unwrap(message.structValue as any);\n    } else if (message?.hasOwnProperty(\"listValue\") && message?.listValue !== undefined) {\n      return ListValue.unwrap(message.listValue);\n    } else if (message?.hasOwnProperty(\"nullValue\") && message?.nullValue !== undefined) {\n      return null;\n    }\n    return undefined;\n  },\n};\n\nfunction createBaseListValue(): ListValue {\n  return { values: [] };\n}\n\nexport const ListValue: MessageFns<ListValue> & ListValueWrapperFns = {\n  wrap(array: Array<any> | undefined): ListValue {\n    const result = createBaseListValue();\n    result.values = (array ?? []).map(Value.wrap);\n    return result;\n  },\n\n  unwrap(message: ListValue): Array<any> {\n    if (message?.hasOwnProperty(\"values\") && globalThis.Array.isArray(message.values)) {\n      return message.values.map(Value.unwrap);\n    } else {\n      return message as any;\n    }\n  },\n};\n\nwrappers[\".google.protobuf.Struct\"] = { fromObject: Struct.wrap, toObject: Struct.unwrap } as any;\n\ninterface MessageFns<T> {\n}\n\ninterface StructWrapperFns {\n  wrap(object: { [key: string]: any } | undefined): Struct;\n  unwrap(message: Struct): { [key: string]: any };\n}\n\ninterface AnyValueWrapperFns {\n  wrap(value: any): Value;\n  unwrap(message: any): string | number | boolean | Object | null | Array<any> | undefined;\n}\n\ninterface ListValueWrapperFns {\n  wrap(array: Array<any> | undefined): ListValue;\n  unwrap(message: ListValue): Array<any>;\n}\n"],"names":["ListValue","NullValue","Struct","Value","createBaseStruct","fields","wrap","object","struct","undefined","key","Object","keys","unwrap","message","createBaseValue","value","result","nullValue","boolValue","numberValue","stringValue","globalThis","Array","isArray","listValue","structValue","Error","hasOwnProperty","createBaseListValue","values","array","map","wrappers","fromObject","toObject"],"mappings":"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"}